#Break the Matrix intake game
Intake project “Break the Matrix”
Since I had another year to apply for HBO I knew I wanted to use the time to visit open days before making a decision. Since most open days are planned on the exact same day and I could only visit one at a time, it took a few cycles to visit most schools. This meant that I applied at Buas late and I didn’t have much time to work on the intake project.

For the intake project at buas I needed to make a game using a template buas made available in C++. The idea is to make a game in C++ without using a conventional game engine. The template has a game loop and a screen buffer that I can access using code. Before starting the project I followed a tutorial provided by Buas to learn how to use the template to make games. When I got far enough into the tutorial I started designing the game. The theme that was given is bounce. I decided to make a game inspired by the 1973 Atari game breakout. I wanted to make an auto-battler where the player chooses what shapes to add to the game. The shapes make the game harder, as the movement of the ball is harder to predict. Given the low impact of the decision and the limited time I decided to scrap the auto-battler element and instead design a set of levels using different shapes.

Display
In the tutorial I learned how to make a tile map to display sprites on a grid. I made a tile set in paint with tiles of 64x64 pixels, divided by a one pixel line. in code I store a pointer to the location of the file in memory, then use math to copy the correct pixel to the screen buffer. By doing this for every cell in the grid I can draw the blocks onto the screen. I can then store tile data in an array, to keep track of what tile should go where.
I also wanted to support different colors of each tile, so I could make the levels pretty. To avoid making the tilemap huge I dicided to make every tile black or white, so I can test if a pixel should be colored or not. If it should be colored I get the color code from an array and store the index in the tile data array. This way I can assign a color to each tile using a color palette. 

Paddle and ball
Next I added a ball to the game. I store it’s position using an x and y coordinate. I also keep the momentum as an x and y variable. I added a paddle to the game that follows the mouses horizontal position. The balls follows the paddles position until the player uses left click, when the ball gets vertical momentum. Every frame the ball makes it’s pixels black to match the backgroundcolor, moves to the next location and fills the pixels in it’s new locations with white. The shape of the ball is stored in an array, so I can later use these coordinates for collision. The coordinates are stored as a number of pixels offset from the center of the ball. To draw the ball on the screen I loop through all coordinates and add the position of the ball to calculate the correct position. 

I then added borders around the screen, so the ball can bounce against them. When the new position of the ball is off the screen I invert the horizontal or vertical momentum and recalculate the new position of the ball. When the ball lands on the paddle I want the ball to bounce based on where on the paddle the ball landed. I did this by comparing the position of the ball with the position of the paddle. The difference between the two is either positive or negative. I set the horizontal momentum to inverse of the difference and the vertical to 1 for up. I then normalize the vector by dividing the components of the vector by the length of the vector. This way the ball always has a constant speed, just the direction changes. This makes the game much easier to balance, as the speed is constant. This also makes the game more interesting, as the direction the ball travels changes the speed at which the player must react.

Collision
To detect collision between the ball and the shapes I used the array of coordinates of the ball, but only chose the 16 most important points to test the color of the pixel on the screen where the ball is about to move to. If the color is not the ball or the background the ball must be hitting a shape. When this happens It activates a function called “Collision”. when this function activates it looks in the tile data array to see what tile the ball hit. This shape is then removed from the board. The function also calculates how the ball needs to bounce. Based on the type of tile the function uses different mathematical comparisons in if statements to figure out what side the ball hit the shape. When the balls hits the bottom of a square the ball needs to bounce differently then if it hit the side of the square or the diagonal of a triangle. Based on the side that was hit I set the value of two variables called shapeAngleToBounceX and shapeAngleToBounceY. This creates a vector from the position where the ball hit in the direction of the normal direction of the side of the shape that the ball hit. For circular sides I used an imaginary center of the circle and the position of the ball to create the vector, then normalizes this vector. Using this vector I then call the “Bounce” function to calculate how the ball will bounce off.

The bounce function uses a formula I found online: .This formula uses the shapeAngleToBounce vector and the momentum of the ball to calculate how the ball will bounce off. The function first calculates the dot product then slots that in the formula. To make sure that the code doesn’t bounce horizontally forever I added a test condition. If the ball’s horizontal or vertical speed is less then 0.05f the speed is set to 0.05f. This way the ball can never get stuck.
